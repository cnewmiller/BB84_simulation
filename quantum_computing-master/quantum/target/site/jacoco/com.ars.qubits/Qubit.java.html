<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Qubit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QuantumComputingLib</a> &gt; <a href="index.source.html" class="el_package">com.ars.qubits</a> &gt; <span class="el_source">Qubit.java</span></div><h1>Qubit.java</h1><pre class="source lang-java linenums">package com.ars.qubits;
/**
 * &lt;h1&gt;QuantumComputingLib&lt;/h1&gt;
 * QuantumComputingLib is a Java library for performing Quantum Computations.
 * This library provides methods for performing operations on qubits ( apply gates,
 * tensor products) and for performing basic operations with 2D-arrays ( matrices). 
 * @author Mihai Seba
 * @version 1.0-SNAPSHOT
 */
import java.util.Arrays;

import com.ars.complexnumbers.ComplexMath;
import com.ars.complexnumbers.ComplexNumber;

public class Qubit {

	protected ComplexNumber[] qubitVector;
	
	/**
	 * Constructs a new &lt;code&gt;Qubit&lt;/code&gt; object. 
	 * @param no0 complex number
	 * @param no1 complex number
	 * 
	 */
<span class="fc" id="L25">	public Qubit(ComplexNumber no0, ComplexNumber no1) {</span>
<span class="fc" id="L26">		qubitVector = new ComplexNumber[2];</span>
<span class="fc" id="L27">		qubitVector[0] = no0;</span>
<span class="fc" id="L28">		qubitVector[1] = no1;</span>
<span class="fc" id="L29">	}</span>

	/**
	 * Constructs a new &lt;code&gt;Qubit&lt;/code&gt; object.
	 * @param qubitVector an array of 2 complex numbers
	 */
<span class="fc" id="L35">	public Qubit(ComplexNumber[] qubitVector) {</span>
<span class="fc" id="L36">		this.qubitVector =Arrays.copyOf(qubitVector, qubitVector.length);</span>
<span class="fc" id="L37">	}</span>

	/**
	 * Return the qubit represented as an array of 2 complex numbers.  
	 * @return qubit
	 */
	public ComplexNumber[] getQubit() {
<span class="fc" id="L44">		ComplexNumber[] copyOfQubitVector = qubitVector;</span>
<span class="fc" id="L45">		return copyOfQubitVector;</span>
	}

	/**
	 * Return a string representation of the qubit.
	 * @return string the representation of the qubit
	 */
	@Override
	public String toString() {
<span class="fc" id="L54">		StringBuffer output=new StringBuffer();</span>
<span class="fc" id="L55">		output.append(&quot;[ &quot;);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">		for (ComplexNumber i : qubitVector) {</span>
<span class="fc" id="L57">			output.append(i);</span>
<span class="fc" id="L58">			output.append(&quot; &quot;);</span>
		}
<span class="fc" id="L60">		output.append(&quot;]&quot;);</span>
<span class="fc" id="L61">		return output.toString();</span>
	}

	/**
	 * Check if passed &lt;code&gt;Qubit&lt;/code&gt; is equal to the current.
	 * @param o the qubit to be checked
	 * @return true if the two qubits are equals, otherwise false
	 */
	@Override
	public boolean equals(Object o) {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">		if (o instanceof Qubit) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">			if (this.qubitVector.length != ((Qubit) o).getQubit().length) {</span>
<span class="fc" id="L73">				return false;</span>
			}
<span class="fc bfc" id="L75" title="All 2 branches covered.">			for (int i = 0; i &lt; this.qubitVector.length; i++) {</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">				if (this.qubitVector[i].equals(((Qubit) o).getQubit()[i])==false) {</span>
<span class="fc" id="L77">					return false;</span>
				}
			}
<span class="fc" id="L80">			return true;</span>
		}
<span class="nc" id="L82">		return false;</span>
	}

	/**
	 * Calculate the hashcode of the qubit.
	 * @return int hashcode
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L91">		int hash = 5;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">		hash += (this.qubitVector != null ? Arrays.hashCode(qubitVector) : 0);</span>
<span class="nc" id="L93">		return hash;</span>
	}
	
	/**
	 * Check if qubit state is valid
	 * @return true if the state is valid, otherwise false
	 */
	public boolean isValid(){
<span class="fc" id="L101">		double sum=0.0;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">		for(ComplexNumber c:this.qubitVector){</span>
<span class="fc" id="L103">			double mod=ComplexMath.mod(c);</span>
<span class="fc" id="L104">			sum+=mod*mod;</span>
		}
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">		return (sum==1.0);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>